import pygame
import numpy as np
import random

# Initialize Pygame
pygame.init()

# Set up display
width, height = 800, 800
screen = pygame.display.set_mode((width, height))
pygame.display.set_caption("Game of Life")

# Define the grid size
cols, rows = 80, 80
cell_size = width // cols

# Create the initial grid so that half is green and half is black
grid = np.random.choice([0, 1], size=(cols, rows), p=[0.5, 0.5])


# Function to draw the grid
def draw_grid(surface, grid):
    for x in range(cols):
        for y in range(rows):
            rect = pygame.Rect(x * cell_size, y * cell_size, cell_size, cell_size)
            if grid[x, y] == 1:
                # draws half of the rectangles in green
                pygame.draw.rect(surface, (0, 255, 0), rect)
            # draws the borders in grey
            pygame.draw.rect(surface, (40, 40, 40), rect, 1)


def update_grid(grid):
    new_grid = np.copy(grid)
    for x in range(cols):
        for y in range(rows):
            up_down_neighbors = np.sum(grid[max(0, x):min(cols, x + 1), max(0, y - 1):min(rows, y + 2)]) - grid[x, y]
            right_neighbors = np.sum(grid[max(0, x + 1):min(cols, x + 2), max(0, y - 1):min(rows, y + 2)])
            left_neighbors = np.sum(grid[max(0, x - 1):min(cols, x), max(0, y - 1):min(rows, y + 2)])
            final_sides_grade = (right_neighbors + left_neighbors) / 6 * 0.58
            final_up_down_grade = up_down_neighbors / 2 * 0.42

            if (final_up_down_grade == final_sides_grade):
                color = random.randint(0, 1)
                new_grid[x, y] = color
            elif (final_up_down_grade > final_sides_grade):
                new_grid[x, y] = 1
            else:
                new_grid[x, y] = 0
            rand = random.randint(0, 3)
            if (rand == 2):
                grid[x, y] = random.randint(0, 1)
    return new_grid

# Function to count the special cells
def count_special_cells(grid):
    special_cells = 0
    for x in range(1, cols - 1):
        for y in range(rows):
            if grid[x, y] == 0 and grid[x - 1, y] == 1 and grid[x + 1, y] == 1:
                special_cells += 1
            elif grid[x, y] == 1 and grid[x - 1, y] == 0 and grid[x + 1, y] == 0:
                special_cells += 1
    return special_cells

generation_count = 0
# Main loop
running = True
while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        elif pygame.mouse.get_pressed()[0]:
            pos = pygame.mouse.get_pos()
            x, y = pos[0] // cell_size, pos[1] // cell_size
            grid[x, y] = 1
        elif pygame.mouse.get_pressed()[2]:
            pos = pygame.mouse.get_pos()
            x, y = pos[0] // cell_size, pos[1] // cell_size
            grid[x, y] = 0
        random_int = np.random.randint(1, 10)

    screen.fill((0, 0, 0))
    draw_grid(screen, grid)
    generation_count += 1
    print(f"generation_count: {generation_count}")

    pygame.display.flip()
    grid = update_grid(grid)
    pygame.time.delay(50)

pygame.quit()
