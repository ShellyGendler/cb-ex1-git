import pygame
import numpy as np
import random
import matplotlib.pyplot as plt
# Initialize Pygame
pygame.init()

# Set up display
width, height = 800, 800
screen = pygame.display.set_mode((width, height))
pygame.display.set_caption("Game of Life")
xpoints = np.empty([1, 2000])

# Define the grid size
cols, rows = 80, 80
cell_size = width // cols
counter=0
# Create the initial grid so that half is green and half is black
grid = np.random.choice([0, 1], size=(cols, rows), p=[0.5, 0.5])

# Function to draw the grid
def draw_grid(surface, grid):
    for x in range(cols):
        for y in range(rows):
            rect = pygame.Rect(x * cell_size, y * cell_size, cell_size, cell_size)
            if grid[x, y] == 1:
                 #draws half of the rectangles in green
                pygame.draw.rect(surface, (0, 255, 0), rect)
             #draws the borders in grey
            pygame.draw.rect(surface, (40, 40, 40), rect, 1)

def update_grid(grid):
    new_grid = np.copy(grid)
    for x in range(cols):
        for y in range(rows):
            up_down_neighbors = np.sum(grid[max(0, x):min(cols, x+1), max(0, y-1):min(rows, y+2)]) - grid[x, y]
            right_neighbors = np.sum(grid[max(0, x+1):min(cols, x+2), max(0, y-1):min(rows, y+2)])
            left_neighbors= np.sum(grid[max(0, x-1):min(cols, x), max(0, y-1):min(rows, y+2)])
            final_sides_grade=(right_neighbors + left_neighbors)/6*0.58
            final_up_down_grade = up_down_neighbors/2*0.42
            if (final_up_down_grade == final_sides_grade):
                color = random.randint(0,1)
                new_grid[x, y] = color
            elif (final_up_down_grade > final_sides_grade):
                new_grid[x, y] = 1
            else:
                new_grid[x, y] = 0
            rand=random.randint(0,3)
            if(rand==2):
                grid[x,y]=random.randint(0,1)       
    return new_grid
def random_color():
    return (random.random(), random.random(), random.random())
def count_special_cells(grid):
    special_cells = 0
    for x in range(1, cols - 1):
        for y in range(rows):
            if grid[x, y] == 0 and grid[x - 1, y] == 1 and grid[x + 1, y] == 1:
                special_cells += 1
            elif grid[x, y] == 1 and grid[x - 1, y] == 0 and grid[x + 1, y] == 0:
                special_cells += 1
    return special_cells
# Main loop
for i in range(10):
    ypoints = np.empty([1, 2000])
    counter=0
    running = True
    while counter<2000:
        for event in pygame.event.get():
            counter+=1
            xpoints[0,counter-1]=counter
            rate=count_special_cells(grid)
            ypoints[0,counter-1]=rate
            if event.type == pygame.QUIT:
                running = False
            elif pygame.mouse.get_pressed()[0]:
                pos = pygame.mouse.get_pos()
                x, y = pos[0] // cell_size, pos[1] // cell_size
                grid[x, y] = 1
            elif pygame.mouse.get_pressed()[2]:
                pos = pygame.mouse.get_pos()
                x, y = pos[0] // cell_size, pos[1] // cell_size
                grid[x, y] = 0
            random_int = np.random.randint(1, 10) 
            
        screen.fill((0, 0, 0))
        draw_grid(screen, grid)
        pygame.display.flip()
        grid = update_grid(grid)
        pygame.time.delay(20)
    plt.plot(xpoints, ypoints,color=random_color(),label=f'run_{i+1}')
    print(f"game number {i} finished")
pygame.quit()
plt.show()